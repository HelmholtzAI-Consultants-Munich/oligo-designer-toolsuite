############################################
# imports
############################################

import os
import random
from pathlib import Path
from typing import List, Union

from Bio.SeqRecord import SeqRecord
from joblib import Parallel, delayed

from oligo_designer_toolsuite.utils import FastaParser

from .._constants import (
    SEPARATOR_FASTA_HEADER_FIELDS,
    SEPARATOR_FASTA_HEADER_FIELDS_LIST,
)
from ..utils._checkers_and_helpers import check_if_list, generate_unique_filename

############################################
# Oligo Database Class
############################################


class OligoSequenceGenerator:
    """
    A class to generate oligonucleotide sequences at random or from input FASTA files.

    :param dir_output: The root directory where output files will be stored, defaults to "output".
    :type dir_output: str
    """

    def __init__(
        self,
        dir_output: str = "output",
    ) -> None:
        """Constructor for the OligoSequenceGenerator class."""
        self.dir_output = os.path.abspath(os.path.join(dir_output, "annotation"))
        Path(self.dir_output).mkdir(parents=True, exist_ok=True)

        self.fasta_parser = FastaParser()

    def create_sequences_random(
        self,
        filename_out: str,
        length_sequences: int,
        num_sequences: int,
        name_sequences: str = "randomsequence",
        base_alphabet_with_probability: dict = {
            "A": 0.25,
            "C": 0.25,
            "G": 0.25,
            "T": 0.25,
        },
    ) -> str:
        """
        Generates a specified number of random DNA sequences and writes them to a FASTA file.

        This method creates random DNA sequences of a given length using a specified base composition and
        writes the sequences to a FASTA file. Each sequence is labeled with a unique identifier.

        :param filename_out: The name of the output FASTA file (without extension).
        :type filename_out: str
        :param length_sequences: The length of each generated sequence.
        :type length_sequences: int
        :param num_sequences: The total number of sequences to generate.
        :type num_sequences: int
        :param name_sequences: The base name for each sequence identifier, defaults to "randomsequence".
        :type name_sequences: str
        :param base_alphabet_with_probability: A dictionary specifying the probability distribution of each nucleotide base, defaults to an equal distribution.
        :type base_alphabet_with_probability: dict
        :return: The path to the generated FASTA file.
        :rtype: str
        """

        def get_sequence_random(sequence_length: int, base_alphabet_with_probability: dict) -> str:
            """
            Generates a random DNA sequence of a specified length based on given base probabilities.

            This function creates a random sequence using the provided nucleotide base alphabet and their associated probabilities.
            The sequence is generated by randomly selecting bases according to their specified probabilities.

            :param sequence_length: The length of the random DNA sequence to generate.
            :type sequence_length: int
            :param base_alphabet_with_probability: A dictionary specifying the bases and their probabilities.
            :type base_alphabet_with_probability: dict
            :return: A randomly generated DNA sequence.
            :rtype: str
            """
            bases = list(base_alphabet_with_probability.keys())
            sequence = "".join(
                random.choices(
                    bases,
                    weights=[base_alphabet_with_probability[n] for n in bases],
                    k=sequence_length,
                )
            )
            return sequence

        sequences_set = set()
        while len(sequences_set) < num_sequences:
            num_missing_sequences = num_sequences - len(sequences_set)
            new_sequences = {
                get_sequence_random(length_sequences, base_alphabet_with_probability)
                for _ in range(num_missing_sequences)
            }
            sequences_set.update(new_sequences)

        file_fasta_out = os.path.join(self.dir_output, f"{filename_out}.fna")

        with open(file_fasta_out, "w") as handle_fasta:
            for i, seq in enumerate(sequences_set):
                handle_fasta.write(
                    f">{name_sequences}{SEPARATOR_FASTA_HEADER_FIELDS}regiontype=random_sequence;region_id={name_sequences}_{i}\n{seq}\n"
                )
        return file_fasta_out

    def create_sequences_sliding_window(
        self,
        files_fasta_in: list[str],
        length_interval_sequences: tuple,
        split_region: int = 1,
        stride: int = 1,
        region_ids: Union[str, List[str]] = None,
        n_jobs: int = 1,
    ) -> list:
        """
        Generates oligonucleotide sequences using a sliding window approach and writes them to separate FASTA files for each region.

        This function creates sequences of specified lengths from input FASTA files by sliding a window of varying sizes over the sequences.
        It allows for filtering based on region IDs and handles cases where sequences span split regions (e.g. exon junctions).

        :param files_fasta_in: List of input FASTA files to generate sequences from.
        :type files_fasta_in: list[str]
        :param length_interval_sequences: A tuple specifying the range (min, max) of sequence lengths to generate.
        :type length_interval_sequences: tuple
        :param split_region: The number of bases required on each side of a split sequence (e.g. exon junctions) to include it. Default is 1.
        :type split_region: int
        :param stride: The step size for the sliding window. Default is 1, meaning that the window moves to every base.
        :type stride: int
        :param region_ids: List of region IDs to process. If None, all regions in the OligoDatabase are processed, defaults to None.
        :type region_ids: Union[str, List[str]], optional
        :param n_jobs: Number of parallel jobs to run. Default is 1.
        :type n_jobs: int
        :return: A sorted list of paths to the output FASTA files containing the generated sequences.
        :rtype: list
        """

        def get_sliding_window_sequence(
            entry: SeqRecord, length_interval_sequences: tuple, split_region: int, stride: int
        ) -> str:
            """
            Generates sequences using a sliding window approach from a given DNA sequence.

            This function takes an input sequence and creates subsequences of specified lengths using a sliding window method.
            It also manages coordinates, chromosome, and strand information from the sequence header and excludes regions with
            insufficient bases around split sequences (e.g. exon junctions).

            :param entry: A `SeqRecord` object containing the DNA sequence and its metadata.
            :type entry: SeqRecord
            :param length_interval_sequences: A tuple specifying the minimum and maximum sequence lengths for the sliding window.
            :type length_interval_sequences: tuple
            :param split_region: The number of bases required on each side of a split sequence to include it.
            :type split_region: int
            :param stride: The step size for the sliding window.
            :type stride: int
            :return: The file path to the generated FASTA file containing the sliding window sequences.
            :rtype: str
            """
            entry_sequence = entry.seq
            region, additional_info, coordinates = self.fasta_parser.parse_fasta_header(
                header=entry.id, parse_additional_info=False
            )
            # chromosome and strand information is the same for an entry but parsed as
            # list in the parse_fasta_header, hence, we take only the first element for each
            # if no information provided in fasta file, those entries are None
            chromosome = coordinates["chromosome"][0]
            strand = coordinates["strand"][0]
            list_of_coordinates = []

            # check if loaded region is spanning split sequences (e.g. exon junctions)
            # if yes, calculate which sequences should be excluded
            # because they have too few bases on each side of the split
            split_sequence = len(coordinates["start"]) > 1
            if split_sequence:
                excluded_coordinates = [
                    coord + offset for coord in coordinates["start"][1:] for offset in range(split_region)
                ] + [coord - offset for coord in coordinates["end"][:-1] for offset in range(split_region)]

            # if the fasta header DOES NOT contain coordinates information
            if chromosome is None:
                list_of_coordinates = [None for i in range(len(entry_sequence))]
            # if the fasta header DOES contain coordinates information
            else:
                # coordinates in fasta file use 1-base indixing, which go from 1 (for base 1) to n (for base n)
                # range produces values until end-1 (e.g. range(10) goes until 9) -> add +1
                # the start and end coordinates can be a list for regions spanning split sequences (e.g. exon junctions)
                for start, end in zip(coordinates["start"], coordinates["end"]):
                    list_of_coordinates.extend(range(start, end + 1))
            # sort reverse on minus strand becaus the sequence is translated into the reverse complement by fasta -strand option
            if strand == "-":
                list_of_coordinates.reverse()

            file_fasta_region = generate_unique_filename(
                dir_output=self.dir_output, base_name=region, extension="fna"
            )
            with open(file_fasta_region, "w") as handle_fasta:
                for sequence_length in range(length_interval_sequences[0], length_interval_sequences[1] + 1):
                    # generate sequences with sliding window and write to fasta file (use lock to ensure that hat only one process can write to the file at any given time)
                    if len(entry_sequence) < sequence_length:
                        continue
                    # calculate start positions for the sliding window
                    range_start_positions = range(0, len(entry_sequence) - sequence_length + 1, stride)
                    sequences = [
                        entry_sequence[curr_start_position : curr_start_position + sequence_length]
                        for curr_start_position in range_start_positions
                    ]

                    for i, curr_start_position in enumerate(range_start_positions):
                        seq = sequences[i]
                        seq_start_end = [
                            list_of_coordinates[curr_start_position],
                            list_of_coordinates[(curr_start_position + sequence_length - 1)],
                        ]
                        # sort coordinates for oligos on minus strand
                        start_seq = min(seq_start_end)  # 1-base index
                        end_seq = max(seq_start_end)

                        if not split_sequence:
                            header = f"{region}{SEPARATOR_FASTA_HEADER_FIELDS}{additional_info}{SEPARATOR_FASTA_HEADER_FIELDS}{chromosome}:{start_seq}-{end_seq}({strand})"
                            handle_fasta.write(f">{header}\n{seq}\n")

                        # if split sequence, only consider cases where we have at least x bases on each side of the split sequence
                        else:
                            split_distance = end_seq - start_seq
                            if (split_distance > sequence_length) and (
                                start_seq not in excluded_coordinates and end_seq not in excluded_coordinates
                            ):
                                # Collect and sort all relevant coordinates for split regions
                                all_coordinates = sorted(
                                    [start_seq, end_seq]
                                    + [c for c in coordinates["start"] if start_seq < c < end_seq]
                                    + [c for c in coordinates["end"] if start_seq < c < end_seq]
                                )

                                # Build the header strings, pairing adjacent coordinates
                                header_coordinates = [
                                    f"{chromosome}:{all_coordinates[i]}-{all_coordinates[i+1]}({strand})"
                                    for i in range(0, len(all_coordinates), 2)
                                ]
                                header = f"{region}{SEPARATOR_FASTA_HEADER_FIELDS}{additional_info}{SEPARATOR_FASTA_HEADER_FIELDS}{SEPARATOR_FASTA_HEADER_FIELDS_LIST.join(header_coordinates)})"
                                handle_fasta.write(f">{header}\n{seq}\n")

            return file_fasta_region

        files_fasta_in = check_if_list(files_fasta_in)
        for file_fasta in files_fasta_in:
            self.fasta_parser.check_fasta_format(file_fasta)

        if region_ids:
            region_ids = check_if_list(region_ids)
        else:
            region_ids = [
                region_id
                for file_fasta in files_fasta_in
                for region_id in self.fasta_parser.get_fasta_regions(file_fasta_in=file_fasta)
            ]
            # make keys unique
            region_ids = list(set(region_ids))

        # delete previous content
        for region_id in region_ids:
            file_fasta_region = os.path.join(self.dir_output, f"{region_id}.fna")
            if os.path.isfile(file_fasta_region):
                os.remove(file_fasta_region)

        # create oligos and store all oligos of one region in seperate files
        file_fasta_out = set()
        for file_fasta in files_fasta_in:
            self.fasta_parser.check_fasta_format(file_fasta)
            fasta_sequences = self.fasta_parser.read_fasta_sequences(file_fasta, region_ids)
            files_fasta_oligos = Parallel(n_jobs=n_jobs)(
                delayed(get_sliding_window_sequence)(entry, length_interval_sequences, split_region, stride)
                for entry in fasta_sequences
            )
            for region_id in region_ids:
                files_fasta_oligos_region = [
                    file for file in files_fasta_oligos if os.path.basename(file).startswith(f"{region_id}_")
                ]
                if len(files_fasta_oligos_region) > 0:
                    file_fasta_region = os.path.join(self.dir_output, f"{region_id}.fna")
                    file_fasta_out.add(file_fasta_region)
                    # merge the fasta files into one single file per region
                    self.fasta_parser.merge_fasta_files(
                        files_in=files_fasta_oligos_region, file_out=file_fasta_region, overwrite=False
                    )

            # remove the temporary fasta files
            for file_fasta_oligos in files_fasta_oligos:
                if os.path.isfile(file_fasta_oligos):
                    os.remove(file_fasta_oligos)

        return sorted(list(file_fasta_out))
